const MediaElement = require('./mediaelement')

class WebRTCEndpoint extends MediaElement {
  /*
  The offer must be a string. In browser JS, the string can be obtained from
  the RTCPeerConnection createOffer method and getting the sdp property from the result. Simplified example:

  let pc = new RTCPeerConnection();
  var offer = await pc.createOffer();
  let offerString = offer.sdp;

  offerString is what this method expects as input.
  This method returns the answer SDP string that should be sent to the client
  */
  processOffer (offer) {
    return this.client.processOfferWebRTCEndpoint(offer, this)
  }

  /*
  The answer must be a string. In browser JS, the string can be obtained from
  the RTCPeerConnection createAnswer method and getting the sdp property from the result. Simplified example:

  let pc = new RTCPeerConnection();
  let answer = await pc.createAnswer();
  let answerString = answer.sdp;

  answerString is what this method expects as input.
  This method returns a confirmation of success, no need to respond to the client.
  */
  processAnswer (answer) {
    return this.client.processAnswerWebRTCEndpoint(answer, this)
  }

  /*
  Generates an offer, that must be consumed by the other party. There are two workflows, one that uses generateOffer and processAnswer, and another that uses only processOffer.
  In the first case, the endpoint initiates the connection by generating the offer and accepting the answer. On the second case, the offer is generated by the other party and is consumed by processOffer.
  */
  generateOffer (offer) {
    return this.client.generateOfferWebRTCEndpoint(this)
  }

  /*
  The candidate is an object with three properties:
  -candidate
  -sdpMid
  -sdpMLineIndex

  In browser JS, this object can be obtained from the onicecandidate event that the RTCPeerConnection object throws. Simplified example:

  let pc = new RTCPeerConnection();
  pc.onicecandidate = (e) => {
    client.addIceCandidate(e.candidate);
  };

  In this example, the client object manages the connection to the server, and the addIceCandidate method sends the candidate here.
  The e.candidate object is what this method expects as input.
  */
  addIceCandidate (candidate) {
    return this.client.addIceCandidate(this, candidate)
  }

  /*
  This method should be called and a callback registered to capture all ice candidates produced by the endpoint.
  It's a good idea to register the callback as soon as the endpoint is created to ensure none are missed.
  These candidates should be sent to the client counterpart using whatever channel is appropriate (WebSocket usually).
  */
  registerIceCandidateFound (callback) {
    return this.client.registerIceCandidateFound(this, callback)
  }

  // This method registers a callback that receives messages every time the state of the webrtc endpoint changes.
  registerConnectionStateChanged (callback) {
    return this.client.registerConnectionStateChanged(this, callback)
  }

  // This method starts producing the ice candidates from the endpoint. These candidates should be sent to the client counterpart.
  gatherIceCandidates () {
    return this.client.gatherIceCandidates(this)
  }

  // Bandwidth control functions. These need to be called before sdp negotiation.
  setMinVideoSendBandwidth (bitrate) {
    return this.client.setMinVideoSendBandwidth(this, bitrate)
  }

  setMaxVideoSendBandwidth (bitrate) {
    return this.client.setMaxVideoSendBandwidth(this, bitrate)
  }

  setMinVideoRecvBandwidth (bitrate) {
    return this.client.setMinVideoRecvBandwidth(this, bitrate)
  }

  setMaxVideoRecvBandwidth (bitrate) {
    return this.client.setMaxVideoRecvBandwidth(this, bitrate)
  }
}

module.exports = WebRTCEndpoint
